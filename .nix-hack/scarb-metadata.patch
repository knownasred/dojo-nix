diff --git a/scarb/build.rs b/scarb/build.rs
index bfab290..845fa1e 100644
--- a/scarb/build.rs
+++ b/scarb/build.rs
@@ -61,7 +61,7 @@ fn obtain_core(rev: &str) {
 
 fn download_remote(cairo_zip: &Path, rev: &str) {
     let url: String = format!("https://github.com/starkware-libs/cairo/archive/{rev}.zip");
-    let mut curl = Command::new("curl");
+    let mut curl = Command::new("@curl@");
     curl.args(["--proto", "=https", "--tlsv1.2", "-fL"]);
     curl.arg("-o");
     curl.arg(cairo_zip);
diff --git a/utils/scarb-build-metadata/build.rs b/utils/scarb-build-metadata/build.rs
index e6c1e42..8ae3080 100644
--- a/utils/scarb-build-metadata/build.rs
+++ b/utils/scarb-build-metadata/build.rs
@@ -35,105 +35,6 @@ fn commit_info() {
 }
 
 fn cairo_version() {
-    let cargo_lock = find_cargo_lock();
-    println!("cargo:rerun-if-changed={}", cargo_lock.display());
-
-    let metadata = MetadataCommand::new()
-        .manifest_path("../../scarb/Cargo.toml")
-        .verbose(true)
-        .exec()
-        .expect("Failed to execute cargo metadata");
-
-    let resolve = metadata
-        .resolve
-        .expect("Expected metadata resolve to be present.");
-
-    let root = resolve
-        .root
-        .expect("Expected metadata resolve root to be present.");
-    assert!(
-        // The first condition for Rust >= 1.77
-        // (After the PackageId spec stabilization)
-        // The second condition for Rust < 1.77
-        root.repr.contains("scarb#") || root.repr.starts_with("scarb "),
-        "Expected metadata resolve root to be `scarb`."
-    );
-
-    let scarb_node = resolve.nodes.iter().find(|node| node.id == root).unwrap();
-    let compiler_dep = scarb_node
-        .deps
-        .iter()
-        .find(|dep| dep.name == "cairo_lang_compiler")
-        .unwrap();
-    let compiler_package = metadata
-        .packages
-        .iter()
-        .find(|pkg| pkg.id == compiler_dep.pkg)
-        .unwrap();
-    let version = compiler_package.version.to_string();
-    println!("cargo:rustc-env=SCARB_CAIRO_VERSION={version}");
-
-    if let Some(corelib_local_path) =
-        find_corelib_local_path(compiler_package).map(|p| p.to_string())
-    {
-        println!("cargo:rustc-env=SCARB_CORELIB_LOCAL_PATH={corelib_local_path}");
-    }
-
-    let mut rev = format!("refs/tags/v{version}");
-    if let Some(source) = &compiler_package.source {
-        let source = source.to_string();
-        if source.starts_with("git+") {
-            if let Some((_, commit)) = source.split_once('#') {
-                println!("cargo:rustc-env=SCARB_CAIRO_COMMIT_HASH={commit}");
-                let mut short_commit = commit.to_string();
-                short_commit.truncate(9);
-                println!("cargo:rustc-env=SCARB_CAIRO_SHORT_COMMIT_HASH={short_commit}");
-                rev = commit.to_string();
-            }
-        }
-    }
-    println!("cargo:rustc-env=SCARB_CAIRO_COMMIT_REV={rev}");
-}
-
-/// Find corelib in local cargo cache.
-///
-/// This function lookups `cairo-lang-compiler` crate in local cargo cache.
-/// This cache should be populated by Cargo, on `cargo metadata` call.
-/// It relies on manifest path provided by cargo metadata, and searches parent directories.
-/// If the crate is downloaded from the registry, the corelib will not be included.
-/// If the crate is downloaded as git or path dependency, the corelib should be present.
-fn find_corelib_local_path(compiler_package: &Package) -> Option<Utf8PathBuf> {
-    // The following logic follows Cairo repository layout.
-    // Starts with `cairo-lang-compiler` crate's manifest path.
-    compiler_package
-        .manifest_path
-        // Crate root directory.
-        .parent()
-        // The `crates` directory from Cairo repository.
-        .and_then(|p| p.parent())
-        // The Cairo repository root.
-        .and_then(|p| p.parent())
-        // Corelib should be present in Cairo compiler repository root.
-        .map(|p| p.join("corelib"))
-        // Ensure path exists
-        .and_then(|p| if p.exists() { Some(p) } else { None })
-    // Note, that for registry source, we do not get whole Cairo repository in cache.
-    // Thus the corelib will not be found - only the crate is downloaded.
-}
-
-fn find_cargo_lock() -> PathBuf {
-    let in_workspace = PathBuf::from("../../Cargo.lock");
-    if in_workspace.exists() {
-        return in_workspace;
-    }
-
-    let in_package = PathBuf::from("Cargo.lock");
-    if in_package.exists() {
-        return in_package;
-    }
-
-    panic!(
-        "Couldn't find Cargo.lock of this package. \
-        Something's wrong with build execution environment."
-    )
+    println!("cargo:rustc-env=SCARB_CAIRO_VERSION={{cairo_version}}");
+    println!("cargo:rustc-env=SCARB_CAIRO_COMMIT_REV=refs/tags/v{{version}}");
 }
